
#include "ink.h"
#include "math.h"
#include <profile.h>
extern void __dma_word_copy(unsigned int from, unsigned int to, unsigned short size);

//by srliu. 1: AB merging now. 0: at a breaking-point
volatile __nv uint8_t breaking_flag = 0;

//by srliu. For TSN energy tracking method.
volatile __nv uint8_t tsn_commit_flag = 0;   //
volatile __nv uint16_t count_ab_history = 0;
//volatile __nv uint8_t count_ab_cur = 0;

// get current capacity budget
#define Maximum_Budget 10

const uint16_t Realbudget[Maximum_Budget]={
    //71, 71, 71, 71, 71,
    //71, 71, 71, 71, 71
    1000, 1000, 1000, 1000, 1000,
    1000, 1000, 1000, 1000, 1000
};
volatile __nv uint8_t Budgetidx = 0;

static uint16_t __get_real_budget()
{
    return Realbudget[Budgetidx];
}

static uint16_t __cal_tsn_count(uint8_t history_ab_count, uint8_t iteration){
/** DO use float.
    float rou = ROU;
    float gamma = GAMMA;

    float temp=1.0;
    uint8_t i;
    for(i=0;i<cur_cmt_iteration;i++){
        temp = temp*gamma;
    }
    temp = history_ab_count*rou*temp;

    if(temp>1){
        return (ceil(temp));
    }else{
        return 1;
    }
*/
    //float rou = ROU;
    //float gamma = GAMMA;
    history_ab_count = history_ab_count >> (iteration+1);
    if(history_ab_count>1){
        return (history_ab_count);
    }else{
#if (TSN2||TSN1)
        return (uint16_t)1;
#endif
#if TSN3
        return (uint16_t)65;
#endif
    }
}

// prepares the stack of the thread for the task execution
static inline void __prologue(thread_t *thread)
{
    may_war_t *may_war = &thread->teb_array[thread->CurTebId].may_war;

    buffer_t *buffer = &thread->buffer;

    // copy original stack to the temporary stack
    __dma_word_copy((uint32_t)buffer->buf[0]+(uint32_t)may_war->range_offset_addr_begin,\
                    (uint32_t)buffer->buf[1]+(uint32_t)may_war->range_offset_addr_begin,\
                    may_war->range_size);
    while(HWREG16(DMA_BASE + DMA_CHANNEL_0 + OFS_DMA1CTL)){
    }
}

volatile __nv uint8_t test_count = 0;
#if TSN1
//by zw.
__nv uint8_t tsnstep = 1;
__nv uint8_t tsninit = 2;
#endif

// by srliu. For TSN
volatile __nv uint16_t count_ab_tracking = 0;
volatile __nv uint16_t count_ab_temp = 0;
volatile __nv uint8_t force_cmt_iter = 0;
#if PRF_TIME
// runs one task inside the current thread
__nv float backup_time=0;
__nv float recover_time=0;
#endif
__nv float task_time=0;

void __tick(thread_t *thread)
{
    //uint8_t cur_budget;
    uint16_t real_budget;
    uint8_t energy_deplet;

#if PRF_TIME
    unsigned int backup_end, backup_start;
#endif
    unsigned int task_end, task_start;

    energy_deplet = 0;
    tsn_commit_flag = 0;
    switch (thread->state)
    {
    case TASK_READY:
#if TSN1
        if(tsninit > tsnstep){
            tsninit -= tsnstep;
        }
#endif
        //charging budget.
        real_budget = __get_real_budget();
        Budgetidx = (Budgetidx+1) % Maximum_Budget;
#if PRF_BUDGET
        printf("budgetidx:%d\r\n",(int)Budgetidx);
#endif
        count_ab_history = count_ab_tracking;   //update
#if PRF_ENERGY_EST
        printf("Current(%d-th) power period budget: %d.\r\n",Budgetidx-1,real_budget);
        printf("|+|History(%d-th power period) energy/AB count estimation:%d\r\n",(uint16_t)Budgetidx-2, count_ab_history);
#endif
        count_ab_tracking = 0;
        force_cmt_iter = 0;
        tsn_commit_flag = 0;
        energy_deplet = 0;
        count_ab_temp = 0;

        while(!energy_deplet){
#if PRF_TIME
            //count the backup time.
            PRB_START(backup_start);
#endif
            __prologue(thread); // by srliu: backup May(war) set
#if PRF_TIME
            PRB_END(backup_end);
            backup_time += (backup_end - backup_start)/16.0;
            //backup time count end;
#endif

#if TSN1
            if(tsn_commit_flag){
                tsninit += tsnstep;
            }
#endif
            breaking_flag = 0;
            tsn_commit_flag = 0;
            int curAB = thread->CurTebId;   //backup CurTebId

            while(1)
            {
                float ABtime=0;
#if TSN1
                if(count_ab_temp > tsninit)
                {
                    tsn_commit_flag = 1;
                    break;
                }
#endif
#if TSN2
                if(count_ab_temp >= __cal_tsn_count(count_ab_history,force_cmt_iter)){
                    //force commit
                    tsn_commit_flag = 1;
                    break;
                }
#endif
#if TSN3
                if(count_ab_temp + thread->teb_array[curAB].budget > __cal_tsn_count(count_ab_history, force_cmt_iter)){
                    if(count_ab_temp){
                    //force commit
                    tsn_commit_flag = 1;
                    break;
                    }
                }
#endif

                //if(real_budget <= thread->teb_array[curAB].budget){
                //    energy_deplet =1; //energy is depleted.
                //    break;
                //}
                //real_budget = real_budget - thread->teb_array[curAB].budget;
                //printf("real_budget: %d.\r\n", real_budget);


                // count task execution time;


#if TSN1
                count_ab_temp++;
#endif
#if TSN2
                count_ab_tracking++;
                count_ab_temp++;
                //printf("count_ab_temp of this TASK:%d\r\n", count_ab_temp);
#endif
#if TSN3
                count_ab_tracking = count_ab_tracking + thread->teb_array[curAB].budget;    //accumulate budget
                count_ab_temp = count_ab_temp + thread->teb_array[curAB].budget;
#endif
                PRB_START(task_start);
                curAB = (void *)((task_t)(thread->teb_array[curAB].fun_entry))(thread->buffer.buf[0]);

                PRB_END(task_end);
                ABtime = (task_end - task_start)/16.0;
                if(real_budget <= ABtime){
                    energy_deplet =1; //energy is depleted.
                    task_time += real_budget;
                    break;
                }else{
                    task_time += (task_end - task_start)/16.0;
                }
                real_budget = real_budget - ABtime;

                if(curAB == 0)
                {
                    test_count ++;
                    //energy_deplet = 1;
                    printf("Iteration of this TASK:%d\r\n", test_count);
#if PRF_TIME
                    printf("|=|TASK execution time = %f\r\n", task_time);
                    printf("|=|Backup time = %f\r\n", backup_time);
                    printf("|=|Recovery time = %f\r\n", recover_time);
                    task_time = 0.0;
                    backup_time = 0.0;
                    recover_time = 0.0;
#endif
                    if(test_count>=10){
                        while(1);
                    }
                }
                //if the next TEB is a breaking AB, terminate the TEB
                //DONOT influence count_ab_history update point.
                if(thread->teb_array[curAB].breaking)
                {
                    breaking_flag = 1;
                    break;
                }
            }//while(1)
            if(!energy_deplet||tsn_commit_flag){
                thread->CurTebId = curAB; // budget depleted, but the real energy is not, commit.
#if PRF_ENERGY_EST
                printf("Executed AB number/budget of %d-th commit iteration: %d.\r\n", force_cmt_iter,count_ab_temp);
#endif
                count_ab_temp = 0;
                force_cmt_iter++;
            }
            if(breaking_flag){
                thread->CurTebId = curAB; // budget depleted, but the real energy is not, commit.
            }
        }//while (energy_deplet)
    case TASK_TEBFINISH:
        thread->state = TASK_READY;
    }
}
